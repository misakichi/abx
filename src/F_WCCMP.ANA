
/* ----------------------------------------------------------------------------
  FIL_WcCmp  -- シフトJIS 対応ワイルドカード機能付文字列比較
	int  FIL_WcCmp(B F *key, B F *st, short flg);
	proc wccmp(key:d, st:d,flg:w);cdecl
	入力
		key		ワイルドカード文字を含む文字列
		st		文字列
		flg		bit 0:  ? の機能を 0:有効  1:抑止
				bit 1:  * の機能を 0:有効  1:抑止
				bit 2:  [ [^ の機能を 0:有効  1:抑止
				bit 3:  ^ の機能を 0:有効  1:抑止
				bit 4:  MS全角     0:対応  1:非対応
	出力
		ax 	結果

	文字列 key と st を比較し、マッチすれば０をしなければ０以外を返す。
	返される値の意味は、
		0		key と st はマッチした
		-1		key の指定がおかしい（ワイルドカード文字の指定ミスなど)
		-2		st は key よりも文字列長が短い
		正数n	st は 先頭 n-1 バイトで key とマッチした（st は key より長い）

	st は極端に長すぎてはいけない。一応、63Kバイトくらいに対応しているはず。
	（正確には64K - 18バイトくらい？）
	（ポインタの正規化はおこなわないので、呼び出し側で注意すること）

	文字列の終端は'\0'. 文字は全角(2ﾊﾞｲﾄ)文字も１文字として扱われる.

	ワイルド・カード文字の意味（c は 半角か全角文字の 1文字のこと）
		*	  0文字以上の任意の文字列にマッチ.
		?	  任意の1文字にマッチ.
		^c	  c 以外の任意の１文字にマッチ.
		[..]  [  ] でくくられた文字列（１文字以上）中のどれか１文字にマッチ.
		[^..] [^ ] でくくられた文字列（１文字以上）中にない１文字にマッチ.

　　括弧（[..],[^..]）のなかではワイルドカード文字の機能は抑制される。
　　括弧のなかに']' を含めたい場合は、[]abc] や [^]ed] のように、'[' や '[^'
	の直後に']'を置く。
	括弧内では、A-Z のように,'-'を用いて文字コードで A から Z の範囲を指定で
	きる。ただし、'-' の両側に文字がないといけない。[-abc] や [abc-] のよう
	に,'[' や '[^' の直後や ']' の直前に '-' があるばあい,'-'は 1文字として
	扱われる。[0-9-A] というようなのは不定扱い（実際にはこの版では[0-99-A]と
	指定されたばあいと同じ動作をして、エラーにしていない）
	あと'-' の右側の文字は左側の文字よりも大きいものを指定しなければならない。
	Z-A ではマッチしない。
   --------------------------------------------------------------------------*/
//	1992-1995	writen by M.Kitamura
module FIL_WCCMP
	c_name "","",1

@define IsKanji(c)  ((c >= 0x81) && (c <= 0x9f) || (c >= 0xE0 && c <= 0xFC))

*proc FIL_WcCmp(key:dword, fstr:dword, flg:w);cdecl;far
	//out ax
enter
	save cx,bx,dx,si,di,es,ds
	const _N_ = -2, _E_ = -1, _Y_ = 0
	local  sptr:word
	assume ds:nothing, es:nothing

	flg &= 0x0f
	FIL_GetZenStatMACRO
	if (ax)
		flg |= 0x10
	fi
  @if 1	//ポインタの正規化はおこなわない.
	ds.si = key
	es.di = fstr
	sptr = di
  @else
	bx.ax = key
	dx.cx = fstr
	//ds.si = bx.ax と es.di = dx.cx 。ポインタの正規化を行う
	si = ax
	ax >>= 4
	bx += ax
	ds = bx
	di = cx
	cx >>= 4
	dx += cx
	es = dx
	si &= 0x0F
	di &= 0x0F
	sptr = di
  @endif

	loop.w
		al = b[si]
		++si
		if ((flg & 0x10) == 0 && IsKanji(al))
			ah = b[si]
			go.w (ah == '\0') RTS_ERR
			ah <=> al
			++si
			gosub	CX_GET	//(di)
			go.w (ax != cx) RTS_NO
			next.w
		fi
		ah = 0
		if (al == '*' && (flg & 0x02) == 0)
			loop
				FIL_WcCmp ds.si, es.di, flg
				go.w (ax == _Y_) RTS_YES
				go.w (ax == _E_) RTS_ERR
				gosub	CX_GET	//(di)
			endloop (cx)
			go RTS_N
		fi
		if (al == '?' && (flg & 0x01) == 0)
			gosub	CX_GET	//(di)
			go (cx == '\0') RTS_N

		elsif (al == '^' && (flg & 0x08) == 0)
			gosub	AX_GET	//(si)
			go.w (ax == 0) RTS_ERR
			gosub	CX_GET	//(di)
			go (ax == cx) RTS_N

		elsif (al == '[' && (flg & 0x04) == 0)
			gosub	CX_GET	//(di)
			go (cx == 0) RTS_N
			gosub	AX_GET	//(si)
			dl = 0
			if (ax == '^')
				dl = 1
				gosub	AX_GET	//(si)
			fi
			bx = 0xffff
			go J0
  RTS_N:
			go RTS_NO

			loop
				if (ax == '-')
					gosub	AX_GET	//(si)
					go (ax == '\0') RTS_ERR
					if (ax == ']')
						go (bx == cx) J1
						go J2
					fi
					go (cx >= bx && cx <= ax) J1
				else
 J0:
					if (ax == cx)
 J1:
						go (dl) RTS_NO
						loop
							gosub	AX_GET	//(si)
							go (ax == 0) RTS_ERR
						endloop (ax != ']')
						exit
					fi
				fi
				bx = ax
				gosub	AX_GET	//(si)
				go (ax == '\0') RTS_ERR
				if (ax == ']')
 J2:
					exit (dl)
					go RTS_NO
				fi
			endloop

		else
			gosub CX_GET	//(di)

			if (ax != cx)
				go (ax) RTS_NO
				go ((di -= sptr) == 0) RTS_NO
				dx = ax = di
				go RTS
			fi
			go (cx == 0) RTS_YES
		fi
	endloop// (ax)
 RTS_YES:
	ax = _Y_
	//di -= sptr
	//dx = di
 RTS:
	return

 RTS_ERR:
	ax = _E_
	go RTS_NO2

 RTS_NO:
	ax = _N_
 RTS_NO2:
	//dx = 0
	go RTS


CX_GET:	//(es.di)
//	in	  es
//	out   cx,di
//	break fx

	ch = 0
	cl = b[es:di]
	++di
	if ((flg & 0x10) == 0 && IsKanji(cl))
		ch = b[es:di]
		++di
		go (ch == 0) CX_GET_J1
		ch <=> cl
	fi
	ret
  CX_GET_J1:
	cl = 0
	ret

AX_GET:	//(ds.si)
//	in	  ds
//	out   ax,si,cf
//	break fx
	ah = 0
	al = b[si]
	++si
	if ((flg & 0x10) == 0 && IsKanji(al))
		ah = b[si]
		++si
		go (ah == 0) AX_GET_J1
		ah <=> al
	fi
	ret
  AX_GET_J1:
	al = 0
	ret

endproc


endmodule

